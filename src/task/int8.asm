;; Mini16 INT8 utilities
;; taken from my blogpost:
;;     https://sebastian.graphics/blog/16-bit-irq0-assembly-example.html

	;; This program:
	;; 1.  setup Programmable Interval Timer (PIT)
	;; 2.  setup INT8 which handles interrupts generated by PIT.
	;;     PIT have multiple (3) channels and channel 0 is connected
	;;     to PIC (which is a chip that arranges interrupts) as
	;;     IRQ0, which translates to INT8.
	;;     If you want sound you can use channel 2 because it's
	;;     connected to the PC Speaker - not the actual speaker you
	;;     are using; it's a beeper that's on (probably) all (at
	;;     least desktop) IBM compatibles. But this example isn't
	;;     about that.
	;; We can setup PIT to generates interrupts at specified interval
	;; which will force the CPU to *abandon* the current task and work
	;; on something else; this can be used to do all sorts of stuff,
	;; including preemptive multitasking stuff by hooking a scheduler at
	;; INT8. In modern webdev terms it's like having a callback that
	;; got called by another party asynchronously and your single
	;; thread JavaScript runtime has to handle that (because single
	;; thread). Or you can see the INT8 handler as (by itself) another
	;; task as well.

	;; NOTE: using 80186 because of PUSHA. maybe change in the future?
	.186
	.model tiny
	.code

	;; NOTE: we need to do this because normal func only has RET.
	;; void int8_load_handler_near(
	;; 	void* callback    // [AX]
	;; )
	public int8_load_handler_near_
int8_load_handler_near_:
	LEA SI, _INT8_CALLBACK_ADDR
	MOV CS:[SI], AX
	RET

_INT8_CALLBACK_ADDR: DW 0

	;; The wrapping INT8 handler
_INT8:	PUSHA

	LEA SI, _INT8_CALLBACK_ADDR
	MOV AX, CS:[SI]
	CALL AX

	;; Sending End Of Interrupt signal to 8259 PIC
	;; This is to notify 8259 the interrupt handling is over and it's
	;; allowed to send more interrupt signal now.
	MOV AL, 20H
	OUT 20H, AL

	;; Now we restore the registers.
	POPA
	
	;; Setting Interrupt Enable flag
	;; This flag will be cleared when executing the interrupt handler
	;; so that the interrupt itself won't be interrupted, but we have
	;; to set it manually so that CPU will acknowledge other interrupts
	;; after the handling, or else nothing will display on the screen
	;; ever again (unless some code that directly writes the video
	;; memory got executed) and keyboard won't work because it requires
	;; interrupt to be enabled.
	STI

	;; You need to use IRET inside interrupt handler - it does things
	;; a little bit different than normal RET. Also a good indicator
	;; that this part of the program is probably not called by normal
	;; means.
	IRET

	;; void int8_register_near(
	;; 	unsigned int tick,  // [AX]
	;; )
	public int8_register_near_
int8_register_near_:
	PUSH BP
	MOV BP, SP
	PUSH AX
	;; Setting up the INT8 handler.
	;; In IBM PC (real mode), there's an Interrupt Vector Table at
	;; 0000h:0000h that contains the location for interrupt INT 0~255
	;; in 2 16-bit numbers of "OFFSET-SEGMENT". We can modify the values
	;; in this table to control where the CPU will jump to when there's
	;; an interrupt. By the design of IBM PC the PIT is connected as IRQ0
	;; through the 8259 PIC, which is eventually mapped to INT 8.
	;; Remember that all of this is only for IBM PC; this is only an
	;; IBM PC thing. But non-IBM PC x86 machines are kinda rare nowadays;
	;; almost all x86 PC nowadays are IBM PC compatible.
	;; Make ES:[BX] points to the memory location storing the actual
	;; location for INT 8, which is 0000h:0020h. (How to calculate: 2
	;; 16-bit numbers which is 4 bytes per table entry, this multiplied
	;; by 8 equals 32, which is 20h in hexadecimal.)
	MOV AX, 0
	MOV ES, AX
	MOV AX, 0020h
	MOV BX, AX

	;; Fill in the "OFFSET" part:
	LEA SI, _INT8
	MOV ES:[BX], SI
	
	;; NOTE: the original code is compiled into a .COM file, which means
	;; that everything will not exceed 64KBytes. by doing this here we
	;; assumes that the kernel size is less than 64KBytes or else registering
	;; a task scheduler with this proc will (probably) not work (properly).
	ADD BX, 2
	MOV AX, CS
	MOV ES:[BX], AX
	
	;; Setting up the PIT.
	;; You setup PIT by sending bytes to specified I/O ports.
	;; 	0x40: channel 0 data port (r/w)
	;; 	0x41: channel 1 data port (r/w)
	;; 	0x42: channel 2 data port (r/w)
	;;      0x43: command port (write only)
	;; PIT setup works as follows: you send the command that
	;; configures the channel, you send the *initial value* of the
	;; register for the channel, then PIT will constantly decrease
	;; the value of the register, and when the value reaches zero
	;; something happens. Depending on the configuration something
	;; else might/can happen too. Data ports are for setting or
	;; reading register counts. The registers are 16-bit. So it's
	;; "SOME_CONSTANT_HERE / value_you_put_in_register" Hz instead
	;; of just "value_you_put_in_register" Hz.
	;; The constant is 1193182 (Hz). Some sources say it's 1193180,
	;; But it really does not matter because the number is big. This
	;; allows us to have a frequency of anywhere between a little
	;; bit more than 18 Hz and 596591 Hz (the counter value of 1
	;; is prohibited for various reasons. The available frequencies are
	;; discrete values of course, e.g. you can't have exactly 8000 Hz).
	;; Because we're writing video memory we want to actually *see*
	;; the thing working, we'll take the slowest option available,
	;; with which we'll have to treat the register as 16-bit binary
	;; counter. (PIT has a BCD mode which I can't think of its uses)
	;; 
	;; 	(2-bit) Channel: Channel 0
	;; 	(2-bit) Data port access: Access low and high byte
	;; 	(3-bit) Operating mode: Mode 3 square wave generator mode
	;; 	(1-bit) Counter mode: 16-bit binary
	;;
	;; The interrupt will only be generated when channel 0 output
	;; changes from low to high (rising edge). In a lot of sources
	;; there's this "Interrupt On Terminal Count" mode and you might
	;; think this is the mode we should use. No. In this mode the
	;; output will remain high until the next time we send a value
	;; to the data port, which certainly isn't desirable in our use
	;; case. Normally you'll use mode 2 or mode 3 that will reload
	;; the previously configured value repeatedly.
	;; All of this will gives us the configuring command for 0x43:
	MOV AL, 00110110b	; or MOV AL, 36h
	OUT 43h, AL
	;; And now the frequency:
	POP AX
	OUT 40h, AL
	MOV AL, AH
	OUT 40h, AL
	
	;; Exit the main process.
	;; If all goes well it won't affect the interrupt handling.
	MOV SP, BP
	POP BP
	RET
	
	end
	